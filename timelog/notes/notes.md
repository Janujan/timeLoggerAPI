# Time Logger Guide

The purpose of this document is to go over all the lessons learned from creating the time logger api. I hope to create a succint guide to help review the work that i did so that I can re-learn the project fast as well as have a nice study guide for showcasing this project.

It basically acts as documentation and a summary of the project.

## Project Summary
[situtation]
I found that ever since I started working fulltime, my time would slip away and I couldnt actually remember how I was spending my time outside of work. I wanted to be able to review the tasks I did in a given week/month and get feedback on how well i was spending my time.

I looked online for a logging application but I couldnt find one that worked for me. I decided to make one since it seemed simple enough.

[action]
I've been wanting to improve my Java experience since I got to TD and also build on the Spring framework. I decided to scope the project to expose a logging system via a RESTful API. 

My technology stack was:
- Spring REST Framework
    - Spring Security
    - Hibernate
- MySQL Database
- Postman
- Github

[result]
I started using the application myself to improve feedback on my time-management! I was also able to share my project with friends who also felt the same way and I got to capture bugs/features that would improve the platform.
- [feature] add a priority flag for logs
- [bug] logs not updating through update route
- [bug] BCrypt encoder is null in the user class for set password because the bean would not autowire


## Design Decisions

**How should I store the relationship between logs and users?**

The obvious answer was to do a ManyToOne relationship between a log and a user. However, the way hibernate works, if I were to add the @OneToMany annotation to the Log object under User, Hibernate will create a join table called user_log to track the relationship. Which is pretty inefficient.

A better solution was to do ManyToOne on the log side and query logs by user afterwords. This is great for two reasons:
- there is no intermediate join table generated by hibernate
- I can efficiently load my logs when I need to load them and not have them tied too closley with users elsewhere.
    - There is a subpoint to be made on eager/lazy loading in hibernate. Eager loading is that if my user class had a log class with OneToMany associated with it, then all the logs by that user get loaded when the User is loaded. To avoid this, you have to set the loading type to lazy, which will only retrieve logs when the Log data is necessary.


**How should i deal with authentication/authorization?**

Since this was a RESTful API, I wanted to use a modern authorization scheme. I didnt want to have the user pass their user credentials every time a call was made to the API as that wasnt exactly safe (this is the Basic Auth scheme). I opted to design a OAuth2.0 system where the user passes along their credentials at the beginning of their session and recieve an auth token to be used for subsequent requests.

This was a very interesting task as I had to leverage Spring Security to lockdown the API.

When a request comes in, it is routed by Spring to the endpoint that the user requested. Along the route, there are filter chains that do the decision making to get to the right route. One of the filter chains is a **UsernameAndPasswordAuthentication** Filter. To bypass this filter when the api is locked down by user credentials, I created my own filter to check the token passed in by the request header.

The custom filter extends the **OncePerRequestFilter** in Spring Security and simply implements one function: **doFilterInternal()**.

The logical flow of the filter is as follows:
- check if a token exists
- extract the username of the token and see if its valid
- check if the token is expired
- set that the authentication has passed (so that the UsernameAndPassword filter is skipped in the chain)

When a token is generated, it bakes in a dictionary called claims. Claims usually can mean roles or anything else you want to add in to the token. To retreive the different claims in the token, there is a claims resolver class that is leveraged by the utility.

My time limit for tokens is 1 hour.

## Documentation

This section is meant to detail how the application is organized and where to go to develop models/functions/services/routes etc.

A RESTfull applcation is split into three major buckets:
- Models
    - Repositories
- Controllers
- Services

Models deal with Object-Relational-Mapping (ORM) of classes to SQL objects. Its usually a set of class variables that map into SQL columns. You can also have functions associated with the model. In the case of Log, I override the equals function to have a custom implementation for checking if two logs are the same. Each model will usually have a model repository associated with it. This where you really get to leverage Hibernate where common functions are automatically generated (like findbyid) etc. 
    
Repositiories are interfaces and you can define the custom functions needed for each type of repository.
You can also define functions with SQL statements here as well.

Controllers define the different routes that exist in the application and the logic necessary to handle user requests. They exist as @RestController annotations with @RequestMapping to define the different routes and handling of the different request functions.

Services are utility classes that perform common functions on models (in my case) that help with interacting with the data stored. In this project, I created a UserDetailsService, that gets passed along to Spring Security to handle authentication. The actual service links the UserRepostiory and exposes the username and password fields to be compared in the actual authentication. Another service was the JWTUtility class. This contains all the functionality needed to work with JWT (like generating/validating tokens)

### TO DO:
- add where to go to do things like:
    - change log class/user class
    - add functionality to repositories
    - create new routes
    - security stuff
- create a security section to document flow of security chain

## Notes
### Spring 

This section is for how the Spring framework works. Cover Inversion of Control and Autowiring

Inversion of Control is a software engineering principle where control of objects/portions of programs is transferred to a container/framework.

In traditional programming, we create code that makes calls to different libraries as we need them. But we manage all the different objects and code that gets run. 

The inversion of control philosophy is to have a container manage everything in the program and call our custom code whenever the situation comes up. This way, all the extra libraries are managed by the container, and passed into our custom code as paramaters. 

The best example of this is as follows:

``` 
public class Store{

    private Item item;

    public Store(){
        this.item = new Item1Subclass();
    }
}
```

In the code above, we need to instantiate a new item instance whenever a store is created to satisfy the Item dependancy. Also, that item type is hardcoded (so it could be banana or something).
Now if the store needs a new item(like apple), you need to go into the code and change it. This is a tightly coupled dependancy.

Dependancy Injection is a way to implement IoC by telling the container to handle the object dependancy by exposing getters/setters instead.

```
public class Store{

    private Item item;

    public Store(Item item){
        this.item = item;
    }

    or

    @Autowired
    private Item item;
}


@Compoenent
public class Item
```

Now the actual type of item is handled by the container, and the Store class will be fine as long as the super class is of type item.

https://www.youtube.com/watch?v=Eqi-hYX50MI

Reasons for IOC:
- Helps with decoupling object dependancies
- Helps with testing single components

### Beans

Beans in JAva are just classes that adhere to a specific set of conditions:
- all member variables are private
- public getters/setters
- public constructor with no argument
- the class is serializable


Beans in Spring are instantiated objects that are handled by the IoC container to be used in the application. They are defined with @Component annotation and configured with @Configuration.

The @Bean annotation is applied to a method to specify that it returns a bean to be managed by the Spring context. The Spring context can be loaded from an XML or generated by component scanning the project.


### JWT Tokens 

Json Web Tokens (JWT) have a specific structure in terms of generation and how the actual token is organized. 

First of all, the information needed to generate a token is the principal information (in my case, the username) and claims. Claims are pieces of information asserted about a subject. Its essentially a dictionary of key/value pairs that are baked into the token.

One really good use of the claim is to capture the scope of the user/token. Effectively implement RBAC at the token level. 

There are reserved claims and custom claims. Of the reserved claims, the stuff that I've used is exp(expiration time) and iat( issued at time) to check if the token has expired. 


In terms of organization, the token looks like this:

xxxxx.yyyyy.zzzzz

- x = header
- y = payload
- z = signature

#### JWT header
Contains two piece of information: security algo used and type of token(JWT)

#### JWT payload
This section contains the actual meat of the token. It has all the claims that are part of the token. So in our case, it captures username, expiration time and issued at time. I can also include scope here.

#### JWT signature

To create the signature part you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that.

Good Links:
https://jwt.io/introduction/

## Challenges

## Sql database
Data model design for scabability. I have two main entities that interact in the application: Logs and Users. The logical relationship between the entities is that for a given User there are many logs. OneToMany works from the User side. There are three different ways I could have captured this relationships.

- User class has a @OneToMany annotation with a list of Logs
- Logs class has a @ManyToOne annotation with a user
- Link both with annotations.

The best option to scale hundreds of logs for a given user is to use @ManyTonOne at the user side because:
- you avoid the join_table that JPA generates 
- you can only isolate and extract logs by user without having to load them all at once. 


### Authentication/Authorization
Deciding best authorization/authentication model for user access. I wanted to leverage the api for front-end calls on mobile and web. I also wanted a high level of security.

- Basic Authentication
- OAuth

I went with OAuth because i limit the amount of times the user has to provide their credentials. I also dont need to keep track of sessions for logging in and out.

- I still need to find a way to refresh tokens when they expire.


### Routing

What was the most logical way to route the endpoints that end-users will use. I wanted to create a routing system that followed the user story from getting authorized to manipulating data. 

I also wanted to limit the data passed in via the url parameters because it there are analytics companies that can capture full urls and hence any sensitive information passed as parameters.

In the end I chose: logs/ and /users for each of the major entities. 

I also had all the sensitive information captured either as a token or in the json payload.

https://www.fullcontact.com/blog/2016/04/29/never-put-secrets-urls-query-parameters/

### Hosting/Deployment

fill this out later.

## Developer Guide

So I wanted to capture a rough guide in how to develop for this project. I will basically cover where to go if I wanted to make certain changes.

### Changing  models:
Navigate to /timelog/src/main/java/com/timelog/timelog/models/

Find the class for the model that needs changes.

If you want to create a new model, just name it according to Java conventions and also create a corresponding repository for it. 

#### Note: Repositories are Hibernate features that allow for automatic CRUD operations for a given SQL Database entitiy. 



### Changing controller logic:
If you want to create a new route, you would navigate to timelog/src/main/java/com/timelog/timelog/controllers/

The LogController class deals with all routes related to Log activities. 

The UserController class deals with all routes for Users.

The Controller is for generic responses like lost endpoints and such. 